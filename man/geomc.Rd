% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geomc.R
\name{geomc}
\alias{geomc}
\title{Markov chain Monte Carlo for discrete and continuous
distributions using geometric MH algorithms.}
\usage{
geomc(
  logp,
  initial,
  n.iter,
  eps = 0.5,
  ind = FALSE,
  gaus = TRUE,
  imp = list(enabled = FALSE, n.samp = 300, samp.base = TRUE),
  a = 1,
  show.progress = TRUE,
  ...
)
}
\arguments{
\item{logp}{Either a function that evaluates the logarithm of the un-normalized target density (pdf or pmf) to sample from, or
a list containing at least one element named \code{log.target}. The list may optionally include any of the following elements
specifying additional functions for the base and approximate target densities: \code{mean.base}, \code{var.base}, \code{dens.base},
\code{samp.base}, \code{mean.ap.tar}, \code{var.ap.tar}, \code{dens.ap.tar}, and \code{samp.ap.tar}. See below for details of these functions.
Any optional elements not provided are treated as missing, and default behavior is applied.
\itemize{
\item \code{log.target} A function that evaluates the logarithm of the
un-normalized target density (pdf or pmf). Its first argument must be
the current state vector \eqn{x}, and it must return a numeric scalar.
If the target density requires additional parameters, the user-supplied
\code{log.target} must be written to accept them through \code{...}
\item \code{mean.base} is the mean of the base density \eqn{f}, needs to be written as a function of the current state \eqn{x}.
\item \code{var.base} is the covariance matrix of the base density \eqn{f}, needs to be written as a function of the current state \eqn{x}.
\item \code{dens.base} is the density function of the base density \eqn{f}, needs to be written as a function \eqn{(y,x)} (in this order) of the proposed state \eqn{y} and the current state \eqn{x}, although it may not depend on \eqn{x}.
\item \code{samp.base} is the function to draw from the base density \eqn{f}, needs to be written as a function of the current state \eqn{x}.
\item \code{mean.ap.tar} is the vector of means of the densities \eqn{g_i(y|x), i=1,\dots,k}. It needs to be written as a function of the current state \eqn{x}. It must have the same dimension as \eqn{k} times the length of initial.
\item \code{var.ap.tar} is the matrix of covariance matrices of the densities \eqn{g_i(y|x), i=1,\dots,k} formed by column concatenation. It needs to be written as a function of the current value \eqn{x}. It must have the same dimension as the length of initial by \eqn{k} times the length of initial.
\item \code{dens.ap.tar} is the vector of densities \eqn{g_i(y|x), i=1,\dots,k}. It needs to be written as a function \eqn{(y,x)} (in this order) of the proposed state \eqn{y} and the current state \eqn{x}, although it may not depend on \eqn{x}.
\item \code{samp.ap.tar} is the function to draw from the densities \eqn{g_i(y|x), i=1,\dots,k}. It needs to be written as a function of (current state \eqn{x}, the indicator of mixing component \eqn{kk}). It must return a vector of the length of that of the initial.
}}

\item{initial}{is the initial state.}

\item{n.iter}{is the no. of samples needed.}

\item{eps}{is the value for epsilon perturbation. Default is 0.5.}

\item{ind}{is False if either the base density, \eqn{f} or the approximate target density, \eqn{g} depends on
the current state \eqn{x}. Default is False.}

\item{gaus}{is True if both \eqn{f} and \eqn{g} are normal distributions. Default is True.}

\item{imp}{A list of three elements controlling optional importance sampling.
This list has components:
\itemize{
\item \code{enabled} Logical. If \code{FALSE} (default),
numerical integration is used to compute
\eqn{\langle \sqrt{f}, \sqrt{g} \rangle}. If \code{TRUE},
importance sampling is used instead.
\item \code{n.samp} A positive integer giving the number of Monte Carlo
samples used when \code{enabled = TRUE}.
\item \code{samp.base} Logical. If \code{TRUE}, the samples in the
importance sampler are drawn from the base density \eqn{f};
otherwise they are drawn from the target density \eqn{g}.
Default is \code{FALSE}.
}
When \code{gaus = TRUE}, the \code{imp} argument is ignored.}

\item{a}{is the probability vector for the mixture proposal density. Default is the uniform distribution.}

\item{show.progress}{Logical. Whether to show progress during sampling. Default: TRUE.}

\item{...}{additional arguments passed to \code{log.target}}
}
\value{
The function returns a list with the following components:
\item{\code{samples}}{A matrix containing the MCMC samples. Each row is one sample.}
\item{\code{log.p}}{A vector with the logarithm of the (un-normalized) target density for each MCMC sample.}
\item{\code{acceptance.rate}}{The Metropolis-Hastings acceptance rate.}
\item{\code{gaus}}{The value of the logical gaus.}
\item{\code{ind}}{The value of the logical ind.}
\item{\code{model.case}}{An indicator specifying whether both, neither, or which of the functions \eqn{f} and \eqn{g} are missing.}
\item{\code{var.base}}{The variance used for the base density if not provided by the user.}
\item{\code{mean.ap.tar}}{The mean used for the approximate target density if not provided.}
\item{\code{var.ap.tar}}{The variance used for the approximate target density if not provided.}
}
\description{
geomc produces Markov chain samples from a target distribution.
The target distribution may be either a probability density function (pdf) or a probability mass function (pmf).
Users specify the target by providing an R function that evaluates the log un-normalized pdf or pmf.
The function geomc implements the geometric approach of Roy (2024) to move an initial (possibly uninformed)
base density toward one or more approximate target densities, thereby constructing efficient proposal distributions
for MCMC.
The base density can be user-specified through its mean, covariance matrix, density function, and sampling function.
When the base density is Gaussian, it may be specified using only its mean and covariance; however, providing the
density and sampling functions is recommended when available.
If either or both of the mean and variance arguments and any of the density and sampling functions is
omitted, geomc automatically constructs a base density corresponding to a random-walk proposal with an appropriate scale.
One or more approximate target densities
can be supplied. Just like the base density, each approximate target may be specified through its mean, covariance,
density, and sampling functions.
Gaussian approximate targets may be specified using only their means and covariance matrices, although it is preferred to
supply their densities and sampling functions as well. If either or both of the mean and variance
arguments and any of the density and sampling functions is missing for the approximate target density, then geomc
automatically constructs a diffuse multivariate normal distribution as the approximate target.
If the argument gaus is set to FALSE, then both the base and approximate target can be specified through their
density functions and sampling functions. In this case, any user-supplied mean or covariance functions for these distributions are ignored.
Conversely, if for either the base or the approximate target, the user specifies both a density function and a sampling
function but omits either the mean function or the covariance function, then gaus = FALSE is automatically enforced.
If the target distribution is a pmf (i.e., a discrete distribution),
then gaus=FALSE and imp$enabled=TRUE (not the default values) need to be specified. This ensures that the algorithm uses
importance sampling rather than numerical integration when computing \eqn{\langle \sqrt{f}, \sqrt{g} \rangle} for discrete targets.
}
\details{
Using a geometric Metropolis-Hastings algorithm geom.mc produces Markov chains with the target as its stationary distribution. The details
of the method can be found in Roy (2024).
}
\examples{
log_target_mvnorm <- function(x, target.mean, target.Sigma) {d  <- length(x)
xc <- x - target.mean; Q  <- solve(target.Sigma); -0.5 * drop(t(xc) \%*\% Q \%*\% xc)}
result <- geomc(logp=log_target_mvnorm,initial= c(0, 0),n.iter=500, target.mean=c(1, -2),
               target.Sigma=matrix(c(1.5, 0.7,0.7, 2.0), 2, 2))
               # additional arguments passed via ...
#target is multivariate normal, default choices
result$samples # the MCMC samples.
result$acceptance.rate # the acceptance rate.
result$log.p # the value of logp at the MCMC samples.
#Additional returned values are
result$var.base; result$mean.ap.tar; result$var.ap.tar; result$model.case; result$gaus; result$ind
result<-geomc(logp=list(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4))),
initial=0,n.iter=500) #target is mixture of univariate normals, default choices
hist(result$samples)
result<-geomc(logp=list(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4)),
mean.base = function(x) x,
var.base= function(x) 4, dens.base=function(y,x) dnorm(y, mean=x,sd=2),
samp.base=function(x) x+2*rnorm(1),
mean.ap.tar=function(x) c(0,10),var.ap.tar=function(x) c(1,1.4^2),
dens.ap.tar=function(y,x) c(dnorm(y),dnorm(y,mean=10,sd=1.4)),
samp.ap.tar=function(x,kk=1){if(kk==1){return(rnorm(1))} else{return(10+1.4*rnorm(1))}}),
initial=0,n.iter=500)
#target is mixture of univariate normals, random walk base density, an informed
#choice for dens.ap.tar
hist(result$samples)
samp.ap.tar=function(x,kk=1){s.g=sample.int(2,1,prob=c(.5,.5))
if(s.g==1){return(rnorm(1))
}else{return(10+1.4*rnorm(1))}}
result<-geomc(logp=list(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4)),
dens.base=function(y,x) dnorm(y, mean=x,sd=2),samp.base=function(x) x+2*rnorm(1),
dens.ap.tar=function(y,x) 0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4), samp.ap.tar=samp.ap.tar),
initial=0,n.iter=500,gaus=FALSE,imp=list(enabled=TRUE,n.samp=100,samp.base=TRUE))
#target is mixture of univariate normals, random walk base density, another
#informed choice for dens.ap.tar
hist(result$samples)
size=5
result <- geomc(logp=list(log.target = function(y) dbinom(y, size, 0.3, log = TRUE),
dens.base=function(y,x) 1/(size+1), samp.base= function(x) sample(seq(0,size,1),1),
dens.ap.tar=function(y,x) dbinom(y, size, 0.7),samp.ap.tar=function(x,kk=1) rbinom(1, size, 0.7)),
initial=0,n.iter=500,ind=TRUE,gaus=FALSE,imp=list(enabled=TRUE,n.samp=1000,samp.base=TRUE))
 #target is binomial
 table(result$samples)
}
\references{
Roy, V.(2024) A geometric approach to informative MCMC sampling https://arxiv.org/abs/2406.09010
}
\author{
Vivekananda Roy \href{mailto:vroy@iastate.edu}{vroy@iastate.edu}
}
